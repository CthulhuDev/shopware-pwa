<script>
// import any extra components here
import { SfLink } from '@storefront-ui/vue'
// libraries
import _ from 'lodash'
// simple - and super light - HTML to AST utility
const parser = require('html-parse-stringify2')
// html entities decoderre('html-parse-stringify2')
//
const Entities = require('html-entities').AllHtmlEntities

export default {
  name: 'CmsElementText',
  props: {
    content: {
      type: Object,
      default: () => ({}),
    },
  },
  data: () => ({
    entitiesDecoder: new Entities(),
    extraComponentsMap: {
      cta: {
        conditions(node) {
          return (
            node.type === 'tag' &&
            node.name === 'a' &&
            node.attrs?.class?.match(/btn\s?/)
          )
        },
        renderer(node, children, createElement) {
          // children of an anchor should be a single child of text
          const text = this.unescapeHTML(children[0])
          return createElement(SfLink, {
            class: node.attrs?.class,
            attrs: {
              target: node.attrs?.target,
            },
            props: {
              link: node.attrs?.href,
            },
            scopedSlots: {
              default: () => {
                return text
              },
            },
          })
        },
      },
    },
  }),
  computed: {
    rawHtml() {
      return this.content?.data?.content
    },
    verticalAlign() {
      return this.content?.config?.verticalAlign?.value
    },
    ast() {
      return this.rawHtml ? parser.parse(this.rawHtml) : []
    },
    normalizedAst() {
      const ast = _.cloneDeep(this.ast)
      const keys = Object.keys(this.extraComponentsMap)
      this.visit(ast, (node, parent, key, index) => {
        // checking whether the AST has some components that has to become Vue Components
        for (let i = 0; i < keys.length; i++) {
          const currentKey = keys[i]
          if (this.extraComponentsMap[currentKey].conditions(node)) {
            node.name = currentKey
          }
        }
      })
      return ast
    },
    areThereAnyExtraComponents() {
      return !_.isEqual(this.ast, this.normalizedAst)
    },
  },
  methods: {
    /**
     * Visit each node in the AST - with callback (adapted from https://lihautan.com/manipulating-ast-with-javascript/)
     * @param {*} ast
     * @param {*} callback
     */
    visit(ast, callback) {
      function _visit(node, parent, key, index) {
        callback(node, parent, key, index)
        if (Array.isArray(node)) {
          // node is an array
          node.forEach((value, index) => {
            _visit.call(this, value, node, null, index)
          })
        } else if (this.isNode(node)) {
          const keys = Object.keys(node)
          for (let i = 0; i < keys.length; i++) {
            const child = node[keys[i]]
            if (Array.isArray(child)) {
              for (let j = 0; j < child.length; j++) {
                _visit.call(this, child[j], node, key, j)
              }
            } else if (this.isNode(child)) {
              _visit.call(this, child, node, key)
            }
          }
        }
      }
      _visit.call(this, ast, null)
    },
    /**
     * rendering the ast
     * @param {*} ast AST generated by html-parse-stringify
     * @param {*} createElement vue's createElement
     */
    renderer(ast, createElement) {
      function _render(h, node, parent, key, index) {
        if (Array.isArray(node)) {
          const nodes = []
          // node is an array
          node.forEach((subnode, index) => {
            nodes.push(_render.call(this, h, subnode, node, null, index))
          })
          return nodes
        } else if (this.isNode(node)) {
          // node is either a node with children or a node or a text node
          if (node.type === 'text') {
            return this.unescapeHTML(node.content) // as simple as that
          }
          if (node.type === 'tag') {
            const children = []
            node.children.forEach((child, index) => {
              children.push(_render.call(this, h, child, node, index))
            })
            // if it's an extra component use custom renderer
            if (typeof this.extraComponentsMap[node.name] !== 'undefined') {
              return this.extraComponentsMap[node.name].renderer.call(
                this,
                node,
                children,
                h
              )
            }
            // else, create normal html element
            return createElement(
              node.name,
              {
                attrs: { ...node.attrs },
              },
              [...children]
            )
          }
        }
      }
      return createElement(
        'div',
        {
          class: 'cms-element-text',
        },
        [
          createElement(
            'div',
            {
              class: 'cms-element-text__content',
            },
            [..._render.call(this, createElement, ast)]
          ),
        ]
      )
    },
    /**
     *
     * @param node html-parse-stringify AST node
     * @returns {boolean|boolean}
     */
    isNode(node) {
      return typeof node === 'object' && typeof node.type !== 'undefined'
    },
    /**
     *
     * @param html String to unescape
     * @returns {string} unescaped string
     */
    unescapeHTML(html) {
      return this.entitiesDecoder.decode(html)
    },
  },
  render(createElement) {
    // mimicking v-show behaviour when rawHtml has not yet been hydrated
    if (!this.rawHtml)
      return createElement('div', { class: 'cms-element-text' })

    // mimicking v-html behaviour when there are not special elements in rawHtml
    if (!this.areThereAnyExtraComponents)
      return createElement('div', { class: 'cms-element-text' }, [
        createElement('div', {
          class: 'cms-element-text__content',
          domProps: { innerHTML: this.rawHtml },
        }),
      ])
    // full custom rendering
    return this.renderer(this.normalizedAst, createElement)
  },
}
</script>

<style lang="scss" scoped>
@import '../settings.scss';

.cms-element-text {
  @include sizing-mode-boxed;
  padding: var(--spacer-xl);
}
</style>
